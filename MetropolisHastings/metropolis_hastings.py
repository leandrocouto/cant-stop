import sys
sys.path.insert(0,'..')
import math
import copy
from game import Game
from play_game_template import play_single_game
from players.vanilla_uct_player import Vanilla_UCT
from players.uct_player import UCTPlayer
from players.random_player import RandomPlayer
from MetropolisHastings.parse_tree import ParseTree, Node
from MetropolisHastings.DSL import DSL
from Script import Script
import time
import pickle
import os.path
from random import sample
import numpy as np
import matplotlib.pyplot as plt
import multiprocessing
from concurrent.futures import ProcessPoolExecutor


class MetropolisHastings:
    def __init__(self, beta, player_1, player_2, n_games, n_iterations, k,
    	threshold, tree_max_nodes, dataset_name, n_cores):
        """
        - beta is a constant used in the MH score function.
        - data is a 5-tuple of the game state consisting of: (Game object,
          chosen_play, Q-value distribution, importance, state round, total
          number of rounds)
        - player_1 and player_2 are objects derived from Player used to 
          generate the dataset used as the oracle.
        - n_games is the number of games to be generated between the players.
        - n_iterations is the number of iteration in the main MH loop.
        - k is the number of samples from dataset to be evaluated.
        - threshold will sample data only if the state importance is higher
          than this threshold.
        - tree is a parse tree implementation.
        - dataset_name is the filename of the dataset generated by the oracle.
        - n_cores is the number of cores used in the oracle data generation for
          the parallel calls.
        """
        self.beta = beta
        self.data = []
        self.player_1 = player_1
        self.player_2 = player_2
        self.n_games = n_games
        self.n_iterations = n_iterations
        self.k = k
        self.threshold = threshold
        self.tree_max_nodes = tree_max_nodes
        self.dataset_name = dataset_name
        self.n_cores = n_cores
        self.tree = ParseTree(DSL('S'), self.tree_max_nodes)
        self.all_results = []
        self.passed_results = []
        self.data_distribution = None

        # Original version
        self.column_range = [2,12]
        self.offset = 2
        self.initial_height = 2 
        self.n_players = 2
        self.dice_number = 4
        self.dice_value = 6 
        self.max_game_length = 500

    def run(self):
        """ Main routine of the MH algorithm. """

        # Read the dataset
        with open(self.dataset_name, "rb") as f:
            while True:
                try:
                    self.data.append(pickle.load(f))
                except EOFError:
                    break
        full_run = time.time()
        # Sample k data instances to be used in the evaluation
        if self.k == -1:
            self.k = len(self.data)
        #initial_data = self.sample_from_data()
        initial_data = self.sample_data_from_importance_threshold()

        self.tree.build_tree(self.tree.root)

        # Main loop
        for i in range(self.n_iterations):
            start = time.time()
            # Make a copy of the tree for future mutation
            new_tree = pickle.loads(pickle.dumps(self.tree, -1))

            new_tree.mutate_tree()

            current_program = self.tree.generate_program()
            mutated_program = new_tree.generate_program()

            #print('current')
            #print(current_program)
            #print()

            script_best_player = self.tree.generate_player(
                                                        current_program, 
                                                        self.k, 
                                                        self.n_iterations, 
                                                        self.tree_max_nodes
                                                        )
            script_mutated_player = new_tree.generate_player(
                                                        mutated_program, 
                                                        self.k, 
                                                        self.n_iterations, 
                                                        self.tree_max_nodes
                                                        )

            score_best, _, _, _ = self.calculate_score_function(
                                                        script_best_player, 
                                                        initial_data
                                                        )
            score_mutated, errors_mutated, errors_rate_mutated, data_distribution = self.calculate_score_function(
                                                        script_mutated_player, 
                                                        initial_data
                                                        )
            n_errors = errors_mutated[0]
            n_errors_yes_action = errors_mutated[1]
            n_errors_no_action = errors_mutated[2]
            n_errors_numeric_action = errors_mutated[3]
            total_errors_rate = errors_rate_mutated[0]
            total_yes_errors_rate = errors_rate_mutated[1]
            total_no_errors_rate = errors_rate_mutated[2]
            total_numeric_errors_rate = errors_rate_mutated[3]

            self.data_distribution = data_distribution

            # Accept program only if new score is higher.
            accept = min(1, score_mutated/score_best)


            self.all_results.append(
                                        (
                                            n_errors,
                                            n_errors_yes_action,
                                            n_errors_no_action,
                                            n_errors_numeric_action,
                                            total_errors_rate,
                                            total_yes_errors_rate,
                                            total_no_errors_rate,
                                            total_numeric_errors_rate
                                        )
                                    )
            # If the new synthesized program is better
            if accept == 1:
                self.tree = new_tree
                self.passed_results.append(
                                            (
                                                n_errors,
                                                n_errors_yes_action,
                                                n_errors_no_action,
                                                n_errors_numeric_action,
                                                total_errors_rate,
                                                total_yes_errors_rate,
                                                total_no_errors_rate,
                                                total_numeric_errors_rate
                                            )
                                        )
                print('Iteration -', i, 'New program accepted - Score = ', 
                        score_mutated,'Error rate = ', errors_rate_mutated, 
                        'n_errors = ', n_errors)

            elapsed_time = time.time() - start
            print('Iteration -', i, '- Elapsed time: ', elapsed_time)
            
        best_program = self.tree.generate_program()
        script_best_player = self.tree.generate_player(
                                                        best_program, 
                                                        self.k, 
                                                        self.n_iterations, 
                                                        self.tree_max_nodes
                                                        )

        full_run_elapsed_time = time.time() - full_run
        print('Full program elapsed time = ', full_run_elapsed_time)

        return best_program, script_best_player

    def save_script_to_file(self, program, path):
        """ Save the script generated by one MH iteration to file. """
        if not os.path.exists(path):
            os.makedirs(path)
        script = Script(
                            program, 
                            self.k, 
                            self.n_iterations, 
                            self.tree_max_nodes
                        )
        script.saveFile(path)

    def generate_oracle_data_parallel(self):
        """ 
        Generate data in parallel by playing games between player_1 and 
        player_2. 
        """
        
        # ProcessPoolExecutor() will take care of joining() and closing()
        # the processes after they are finished.
        with ProcessPoolExecutor(max_workers=self.n_cores) as executor:
            # Specify which arguments will be used for each parallel call
            args = (
                    (self.player_1, 
                    self.player_2, 
                    Game(self.n_players, self.dice_number, self.dice_value, 
                        self.column_range, self.offset, self.initial_height
                        ), 
                    self.max_game_length,
                    i
                    ) 
                    for i in range(self.n_games)
                )
            
            executor.map(self.play_single_game, args)
        
        full_data = []
        for i in range(self.n_games):
            # Read the dataset
            with open('data/' + self.dataset_name + '_' + str(i), "rb") as f:
                while True:
                    try:
                        full_data.append(pickle.load(f))
                    except EOFError:
                        break
        # Append game data to file
        with open('data/' + self.dataset_name + '_fulldata', 'ab') as f:
            for data in full_data:
                pickle.dump(data, f)

    def calculate_score_function(self, program, new_data):
        """ 
        Score function that calculates who the program passed as parameter 
        "imitates" the actions taken by the oracle in the saved dataset.
        Return this program's score.
        """
        errors, errors_rate, data_distribution = self.calculate_errors(program, new_data)
        score = math.exp(-self.beta * errors_rate[0])
        return score, errors, errors_rate, data_distribution

    def calculate_errors(self, program, new_data):
        """ 
        Calculate how many times the program passed as parameter chose a 
        different action when compared to the oracle (actions from dataset).
        Return:
            - n_errors is the number of errors that the program chose when 
              compared to the actions chosen by the oracle.
            - n_errors_yes_action is the number of errors that the program 
              chose for the "yes" action.
            - n_errors_no_action is the number of errors that the program 
              chose for the "no" action.
            - n_errors_numeric_action is the number of errors that the program 
              chose when compared to the "numeric" actions chosen by the oracle.
            - chosen_default_action is the number of times the program chose
              the default action (this means it returned false for every if
              condition). Given in percentage related to the dataset.
        """
        n_errors = 0
        n_errors_yes_action = 0
        n_errors_no_action = 0
        n_errors_numeric_action = 0

        n_data_yes_action = 0
        n_data_no_action = 0
        n_data_numeric_action = 0

        for i in range(len(new_data)):
            chosen_play = program.get_action(new_data[i][0])
            oracle_play = new_data[i][1]
            # Compare the action chosen by the synthesized script and the oracle
            if chosen_play != oracle_play:
                n_errors += 1

                if oracle_play == 'y':
                    n_errors_yes_action += 1
                elif oracle_play == 'n':
                    n_errors_no_action += 1
                else:
                    n_errors_numeric_action += 1

            #For report purposes
            if oracle_play == 'y':
                n_data_yes_action += 1
            elif oracle_play == 'n':
                n_data_no_action += 1
            else:
                n_data_numeric_action += 1

        # Proportion yes / no actions
        if n_data_no_action == 0:
            weight = 1
        else:
            weight = n_data_yes_action / n_data_no_action
        n_errors_no_action = n_errors_no_action * weight
        n_data_no_action = n_data_no_action * weight
        total_errors_rate = (n_errors_no_action + n_errors_yes_action + n_errors_numeric_action) / (n_data_yes_action + n_data_no_action + n_data_numeric_action)


        if n_data_yes_action == 0:
            total_yes_errors_rate = 0
        else:
            total_yes_errors_rate = n_errors_yes_action / n_data_yes_action
        if n_data_no_action == 0:
            total_no_errors_rate = 0
        else:
            total_no_errors_rate = n_errors_no_action / n_data_no_action
        if n_data_numeric_action == 0:
            total_numeric_errors_rate = 0
        else:
            total_numeric_errors_rate = n_errors_numeric_action / n_data_numeric_action
        errors = (
                    n_errors, n_errors_yes_action, 
                    n_errors_no_action, n_errors_numeric_action
                )
        errors_rate = (
                        total_errors_rate, 
                        total_yes_errors_rate,
                        total_no_errors_rate,
                        total_numeric_errors_rate
                    )
        data_distribution = (
                            n_data_yes_action,
                            n_data_no_action,
                            n_data_numeric_action  
                        )
        return errors, errors_rate, data_distribution

    def sample_from_data(self):
        """ Sample k random instances from oracle data for evaluation. """

        index_list = sample(range(len(self.data)), len(self.data) - self.k)
        new_data = np.delete(self.data, index_list, 0)
        
        return new_data

    def sample_data_from_importance_threshold(self):
        """ Sample states that have importance higher than self.threshold. """

        new_data = [d for d in self.data if d[3] >= self.threshold]
        return new_data


    def importance_graph(self, path):
        """ 
        Generate a graph plotting the importance of the sorted dataset and the
        average of the game length of the states. 
        """

        sorted_data = []
        with open(self.dataset_name, "rb") as f:
            while True:
                try:
                    sorted_data.append(pickle.load(f))
                except EOFError:
                    break
        
        x = [i for i in range(len(sorted_data))]
        y1 = [sorted_data[i][3] for i in range(len(sorted_data))]
        game_length = [
                        (sorted_data[i][4] * 100)/sorted_data[i][5] 
                        for i in range(len(sorted_data))
                    ]

        intervals = [1, 100, 500, 1000, 5000, 10000, 20000]

        for interval in intervals:
            y2 = []
            start = 1
            it = range(0, len(game_length), interval)
            for i in it:
                data_sum = 0
                if start * interval > len(game_length):
                    my_slice =  game_length[i:]
                    data_sum = sum(my_slice) / len(my_slice)
                else:
                    my_slice = game_length[i:start * interval]
                    data_sum = sum(my_slice) / len(my_slice)
                y2.append(data_sum)
                start += 1
            
            fig, ax1 = plt.subplots()

            ax2 = ax1.twinx()
            ax1.plot(x, y1, 'g-', label='Importance')
            ax2.plot(it, y2, 'b-', label='Game length')
            ax1.legend(loc='upper center')
            ax2.legend(loc='best')

            ax1.set_xlabel('States')
            ax1.set_ylabel('Importance')
            ylabel = 'Average game length percentage of ' + str(interval) + \
                    ' states'
            ax2.set_ylabel(ylabel)

            plt.suptitle("Importance of states - Descending order")
            plt.savefig("importance_graph_" + str(interval))
            plt.close()

    def sort_data_by_importance(self):
        """ Sort the oracle dataset by their importance. """

        if len(self.data) == 0:
            with open(self.dataset_name, "rb") as f:
                while True:
                    try:
                        self.data.append(pickle.load(f))
                    except EOFError:
                        break

        self.data = sorted(self.data, key=lambda tup: tup[3], reverse = True)

        with open(self.dataset_name + 'sorted', 'ab') as f:
            for i in range(len(self.data)):
                pickle.dump(self.data[i], f)

    def play_single_game(self, args):
        """ Play a single game between player_1 and player_2. """

        player_1 = args[0]
        player_2 = args[1]
        game = args[2]
        max_game_length = args[3]
        iteration = args[4]

        is_over = False
        rounds = -1
        # actions_taken actions in a row from a UCTPlayer player. 
        # List of tuples (action taken, player turn, Game instance).
        # If players change turn, empty the list.
        actions_taken = []
        actions_from_player = 1

        single_game_data = []

        # Game loop
        while not is_over:
            rounds += 1
            moves = game.available_moves()
            if game.is_player_busted(moves):
                actions_taken = []
                actions_from_player = game.player_turn
                continue
            else:
                # UCTPlayer players receives an extra parameter in order to
                # maintain the tree between plays whenever possible
                if game.player_turn == 1 and isinstance(player_1, UCTPlayer):
                    if actions_from_player == game.player_turn:
                        chosen_play = player_1.get_action(game, [])
                    else:
                        chosen_play = player_1.get_action(game, actions_taken)
                elif game.player_turn == 1 and not isinstance(player_1, UCTPlayer):
                        chosen_play = player_1.get_action(game)
                elif game.player_turn == 2 and isinstance(player_2, UCTPlayer):
                    if actions_from_player == game.player_turn:
                        chosen_play = player_2.get_action(game, [])
                    else:
                        chosen_play = player_2.get_action(game, actions_taken)
                elif game.player_turn == 2 and not isinstance(player_2, UCTPlayer):
                        chosen_play = player_2.get_action(game)

                if game.player_turn == 1:
                    q_a = dict(player_1.q_a_root)
                else:
                    q_a = dict(player_2.q_a_root)
                if len(moves) > 1:
                    importance = q_a[max(q_a, key=q_a.get)] - q_a[min(q_a, key=q_a.get)]
                    single_game_data.append([game.clone(), chosen_play, q_a, importance, rounds])                
                # Needed because game.play() can automatically change 
                # the player_turn attribute.
                actual_player = game.player_turn
                
                # Clear the plays info so far if player_turn 
                # changed last iteration.
                if actions_from_player != actual_player:
                    actions_taken = []
                    actions_from_player = game.player_turn

                # Apply the chosen_play in the game
                game.play(chosen_play)

                # Save game history
                actions_taken.append((chosen_play, actual_player, game.clone()))

            if rounds > max_game_length:
                is_over = True
            else:
                _, is_over = game.is_finished()
        # Add the total number of rounds to the single game data
        for data in single_game_data:
            data.append(rounds)
        # Append game data to file
        with open('data/' + self.dataset_name + '_' + str(iteration), 'ab') as f:
            for data in single_game_data:
                data = tuple(data)
                pickle.dump(data, f)
